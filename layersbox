#!/usr/bin/env python

import subprocess
import os
import sys
import argparse
import shutil
import re
import yaml
import urllib2
import six
import copy
from zipfile import ZipFile
import tarfile

join = os.path.join

programs = ["docker", "docker-compose"]
base = "base.yml"
conf = "box.yml"
minimal = 'minimal.yml'
# src = os.path.dirname(os.path.realpath(__file__))

minimal_data = '''adapterdata:
    container_name: adapter-data
    image: learninglayers/adapter-data:0.0.1
    env_file:
        - common.env
adapter:
    container_name: adapter
    image: learninglayers/adapter:0.0.1
    volumes_from:
        - adapterdata
    volumes:
        - ./ssl/:/usr/local/openresty/conf/ssl/:ro
        - ./logs/:/usr/local/openresty/logs/
        - ./html/:/usr/local/openresty/nginx/html/:ro
    env_file:
        - common.env
    ports:
        - "80:80"
        - "443:443"
mysqldata:
    image: learninglayers/mysql-data:0.0.1
    env_file:
        - common.env
        - services/mysql/MYSQL.env
    volumes:
        - ./mysql-data/backup/:/backup
mysql:
    image: learninglayers/mysql:0.0.1
    env_file:
        - common.env
        - services/mysql/MYSQL.env
    volumes_from:
        - mysqldata
    # volumes:
    #     - ./mysql/:/var/lib/mysql/
    ports:
        - "127.0.0.1:3307:3306"
mysqlcreate:
    image: learninglayers/mysql-create:0.0.1
    links:
        - mysql
    env_file:
        - common.env
        - services/mysql/MYSQL.env
        - tmp/secret.env
    volumes:
        - ./tmp/sqlfile/:/sqlfile/
'''


def which(program):
    """Emulates the 'which' utility.
    Checks wether a program exists in PATH and is executable

    :program: String containing the name of the program
    :returns: True if the program exists and is executable, False otherwise
    """
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None


def check_programs(programs):
    """Checks if given programs are in PATH

    :program: List of program names
    :returns: True if all programs exist, False otherwise

    """
    for p in programs:
        if not which(p):
            print("% is not installed! Exiting.".format(p))
            return False
    return True


def read_url(dir):
    """Reads the LayersBox URL from the common.env file

    :dest: The directory of the LayersBox
    :returns: the LayersBox URL

    """
    dir_env = join(dir, 'common.env')
    try:
        os.stat(dir_env)
        with open(dir_env, 'r') as f:
            lines = f.readlines()
            p = re.compile('^LAYERS_API_URI=https://(.*)/$')
            for line in lines:
                line = line.strip()
                m = p.match(line)
                if m:
                    return m.group(1)
    except:
        raise


def read_config(dir):
    """Reads the configuration from the config file

    :dir: directory of the layers box
    :returns: the configuration

    """
    conf_yaml = None
    with open(join(dir, conf), 'r') as f:
        conf_yaml = yaml.load(f.read())
    if conf_yaml:
        return conf_yaml
    raise


def write_config(dir, config):
    """Writes the configuration to the config file

    :dir: directory of the layers box
    """
    with open(join(dir, conf), 'w') as f:
        f.write(yaml.dump(config))


def check_tls(dir, url):
    """Checks if the TLS certificate and key are where they should be

    :dest: folder of the LayersBox
    :returns: True if everything is OK, False otherwise

    """
    ssl_path = join(dir, 'ssl/')
    try:
        os.stat(join(ssl_path, url + '.pem'))
        os.stat(join(ssl_path, url + '.key'))
        return True
    except:
        print("Please put your TLS certificate {0}.pem and key {0}.key in {1}"
              .format(url, join(dir, 'ssl/')))
        return False


def generate_cert(dir, domain):
    """Generates a self-signed TLS certificate

    :dir: folder where the certificate and key should be placed
    :domain: domain for that the certificate will be valid
    :returns: True if successful, False otherwise

    """
    if not which("openssl"):
        print("openssl is not installed! Can't generate a certificate.")
        return False
    privkey_file = join(dir, domain + ".key")
    csr_file = join(dir, domain + ".csr")
    cert_file = join(dir, domain + ".pem")
    subj = "/C=DE/ST=NRW/O=RWTH/localityName=Aachen/" +\
           "commonName={}/organizationalUnitName=ACIS/" +\
           "emailAddress=acis@dbis.rwth-aachen.de/"
    if not os.path.isfile(privkey_file):
        print("Generating key file {}".format(privkey_file))
        subprocess.check_output(["openssl", "genrsa",
                                 "-out", privkey_file,
                                 "4096"])
        print("Generating CSR file {}".format(csr_file))
        subprocess.check_output(["openssl", "req",
                                 "-new",
                                 "-batch",
                                 "-subj", subj.format(domain),
                                 "-key", '{}'.format(privkey_file),
                                 "-out", '{}'.format(csr_file)])
        print("Generating certificate file {}".format(cert_file))
        subprocess.check_output(["openssl", "x509",
                                 "-req",
                                 "-days", "3650",
                                 "-signkey", '{}'.format(privkey_file),
                                 "-in", '{}'.format(csr_file),
                                 "-out", '{}'.format(cert_file)])
        # CSR file is not needed anymore
        os.remove(csr_file)
    else:
        print("Certificae or key already exists, refusing to overwrite")
        return False
    return True


def merge_ymls(base, addon, databases=[]):
    """Merges two yml files into one

    :base: base yml data
    :addon: additional component data
    :returns: merged yml data

    """
    # top level containers, that is names like "mysql" and "mysql-data".
    # "name" is the container name, "obj" contains the settings
    for name, obj in addon.copy().iteritems():
        # if there is a key called "needs" then return its value, otherwise return empty list
        needs = 'needs' in obj and obj.pop('needs') or []

        # merges each container of the new service's docker-compose.yml into the base.yml
        merged = data_merge(base, {name: obj})

        # the following code makes basically sure, that databases are created and
        # that the adapter is linking to all containers.
        for need in needs:
            # if it is a container name, do nothing
            if type(need) == str:
                # pass is required in python when a command is required syntactically
                # but nothing needs to be done
                pass
            elif type(need) == dict:
                for k, v in need.iteritems():
                    if k == "create_databases":
                        print("Added database {}".format(v))
                        databases.append(v)
                    else:
                        merged, databases = merge_ymls(merged, {k: v}, databases)
            else:
                print("Need is {}".format(need))
                raise
    # print(merged)

    return merged, databases


class YamlReaderError(Exception):
    pass


def data_merge(a, b):
    """merges b into a and return merged result
    based on
    http://stackoverflow.com/questions/7204805/python-dictionaries-of-dictionaries-merge
    and extended to also merge arrays and to replace the content of keys with
    the same name
    NOTE: tuples and arbitrary objects are not handled as it is totally
    ambiguous what should happen"""
    key = None
    # ## debug output
    # sys.stderr.write("DEBUG: %s to %s\n" %(b,a))
    try:
        if a is None or isinstance(a, (six.string_types, float,
                                       six.integer_types)):
            # border case for first run or if a is a primitive
            a = b
        elif isinstance(a, list):
            # lists can be only appended
            if isinstance(b, list):
                # merge lists
                for i in b:
                    if i not in a:
                        a.append(i)
            else:
                # append to list
                if b not in a:
                    a.append(b)
        elif isinstance(a, dict):
            # dicts must be merged
            if isinstance(b, dict):
                for key in b:
                    if key in a:
                        a[key] = data_merge(a[key], b[key])
                    else:
                        a[key] = b[key]
            else:
                raise YamlReaderError(
                    'Cannot merge non-dict "{}" into dict "{}"'.format(b, a))
        else:
            raise YamlReaderError(
                'NOT IMPLEMENTED "{}" into "{}"'.format(b, a))
    except TypeError as e:
        raise YamlReaderError(
            'TypeError "{}" in key "{}" when merging "{}" into "{}"'
            .format(e, key, b, a))
    return a


def generate_yml(dir):
    """Generates a yml file for docker-compose with the base services
    and all installed ones.

    :dir: directory of the layersbox
    """

    base_config = None
    with open(join(dir, base), 'r') as f:
        base_config = yaml.load(f.read())

    merged = copy.deepcopy(base_config)

    # reads in config file that contains all installed services
    config = read_config(dir)
    services = config['services']
    databases = []
    # for with service_name e.g. being "documentation" and service the value of the
    # service called "documentation"
    for service_name, service in services.iteritems():
        # read in the yml file of the service (docker-compose.yml)
        service_yml = service['yml']
        # open docker-compose.yml file for each service
        with open(join(dir, service_yml), 'r') as addon_file:
            addon = yaml.load(addon_file.read())
            # merged is the base one
            merged, more_databases = merge_ymls(merged, addon)
            # "extend" extends list by appending elements from the iterable
            databases.extend(more_databases)

    # print(yaml.dump(merged))
    with open(join(dir, "docker-compose.yml"), 'w') as f:
        f.write(yaml.dump(merged))

    if databases:
        with open(join(dir, "databases"), 'w') as f:
            for dbs in databases:
                for db in dbs:
                    f.write("{}\n".format(db))



def box_install(args):
    """Adds a new component to a LayersBox

    :args: parsed arguments
    :returns: shell return code

    """
    # the following two lines come from the command line
    dir = args.directory
    repo = args.repository
    #version = args.version
    #tag = args.tag
    if "#" in repo:
        repo, version = repo.split("#")
    ##If tag specified instead of a version, treat the tag as the new version.
    #elif version == None and tag != None:
    #    version = tag
    else:
        version = "master"
    owner, service_name = repo.split("/")
    url = "https://github.com/{}-Dockerfiles/archive/{}.tar.gz".format(repo, version)

    servicedir = join(dir, "services")
    tmp_servicedir = join(dir, "tmp", "services")

    release_tar = join(tmp_servicedir,
                       '{}-{}.tar.gz'.format(repo, version).replace("/", "-"))
    addon_yml = join(servicedir, service_name, "docker-compose.yml")

    try:
        check_yml(dir)
    except:
        print("This directory does not seem to contain a LayersBox")
        return 1

    # only download release if it was not yet downloaded
    if version is "master" or not os.path.isfile(addon_yml):
        # check if "services" directory is already existing, if not, create it
        if not os.path.exists(tmp_servicedir):
            os.makedirs(tmp_servicedir)
        if not os.path.exists(servicedir):
            os.makedirs(servicedir)
        response = urllib2.urlopen(url)
        with open(release_tar, 'w') as f:
            f.write(response.read())
        with tarfile.open(release_tar) as t:
            if os.path.exists(join(dir, "services", service_name)):
                shutil.rmtree(join(dir, "services", service_name))
            os.makedirs(join(dir, "services", service_name))
            dirname = list(x.name for x in t)[0]
            t.extractall(path=servicedir)
            os.rename(join(servicedir, dirname),
                      join(servicedir, service_name))

    # read base.yml which contains the minimal Layers Box
    config = read_config(dir)
    services = config['services']
    services[service_name] = {
        'owner': owner,
        'version': version,
        'yml': addon_yml,
    }
    write_config(dir, config)

    generate_yml(dir)

    # start box with updated docker-compose.yml
    box_start(args)

    # get internal IP of new container
    #TODO: find out somehow which containers to link, e.g. by reading out nginx.conf
    #   (linking only those container names that appear there)
    container_ip = subprocess.check_output(["docker", "inspect",
        "-f", "'{{ .NetworkSettings.IPAddress }}'", service_name]).replace("'", "").strip()

    # write IP into nginx.conf
    # taken from http://stackoverflow.com/questions/13089234/replacing-text-in-a-file-with-python
    replacements = {'http://documentation':'http://' + container_ip}
    with open(join(servicedir, service_name, "nginx.conf")) as infile, open(join(servicedir, service_name, "nginx." + service_name + ".conf"), 'w') as outfile:
        for line in infile:
            for src, target in replacements.iteritems():
                line = line.replace(src, target)
            outfile.write(line)

    # copy nginx.conf into container
    #TODO: parameterize the shell script or run it directly from python
    subprocess.check_output(["./add_nginx_conf.sh"])

    #TODO: send signal HUP to adapter container, either leave it in the add_nginx_conf.sh or do it here

    return 0


def box_start(args):
    """Starts a LayersBox"""
    dir = args.directory
    try:
        url = read_url(args.directory)
        if not check_tls(dir, url):
            return 1
    except:
        print("This directory does not seem to contain a LayersBox")
        return 1
    subprocess.check_output(["docker-compose", "up", "-d"])
    print("You can reach LayersBox now at https://{}/".format(url))
    return 0


def box_stop(args):
    """Stops a LayersBox"""
    try:
        read_url(args.directory)
    except:
        print("This directory does not seem to contain a LayersBox")
        return 1
    subprocess.check_output(["docker-compose", "stop"])
    return 0


def box_logs(args):
    """Shows logs of a LayersBox"""
    subprocess.check_output(["docker-compose", "logs"])
    return 0


def box_ps(args):
    """Shows the states of the services inside the LayersBox"""
    print(subprocess.check_output(["docker-compose", "ps"]))
    return 0


def box_init(args):
    """Initializes a LayersBox"""
    print("Initializing LayersBox...")
    dir = args.directory
    if not os.path.exists(dir):
        os.makedirs(dir)
    url = "THIS SHOULD HAVE BEEN REPLACED"
    try:
        url = read_url(dir)
        print("Found existing configuration, using URL https://{}/"
              .format(url))
    except:
        url = raw_input(
            "Enter the URL the box should be reachable at. \
            (Don't put a / at the end)\nhttps://").strip("/")
        with open(join(dir, "common.env"), 'w') as f:
            f.write("LAYERS_API_URI=https://{}/\n".format(url))
            f.write("LAYERS_API_URL=https://{}/\n".format(url))
            f.write("LAYERS_APP_URI=https://{}/\n".format(url))
        os.makedirs(join(dir, "tmp"))
        with open(join(dir, "tmp", "secret.env"), 'w') as f:
            f.write("\n".format(url))
        os.makedirs(join(dir, "services", "mysql"))
        with open(join(dir, "services", "mysql", "MYSQL.env"), 'w') as f:
            f.write("MYSQL_ROOT_PASSWORD=pass")
    dir_yml = join(dir, base)
    try:
        os.stat(dir_yml)
        print("Found docker-compose configuration")
    except:
        print("No docker configuration found, using minimal configuration")
        with open(dir_yml, 'w') as f:
            f.write(minimal_data)
    shutil.copy(dir_yml, join(dir, "docker-compose.yml"))

    ssl_dir = join(dir, 'ssl/')
    if not os.path.exists(ssl_dir):
        os.makedirs(ssl_dir)
    if not check_tls(dir, url):
        print("No TLS certificate found, generating a self signed certificate")
        generate_cert(join(dir, "ssl/"), url)

    # Downloading and unzippind the landing page
    response = urllib2.urlopen(
        'https://github.com/learning-layers/LayersAPI-LandingPage/releases/' +
        'download/v1.0.0/dist.zip')
    page_zip = join(dir, 'LandingPage.zip')
    with open(page_zip, 'w') as f:
        f.write(response.read())
    with ZipFile(page_zip, 'r') as zip:
        os.makedirs(join(dir, 'html/'))
        zip.extractall(join(dir, 'html/'))
    os.remove(page_zip)

    config = {'services': {}}
    write_config(dir, config)

    print("Initializion complete.")
    print("Make sure port 80 and 443 are not in use on this machine")
    print("You can start your LayersBox with 'layersbox start'")
    # Workaround for logs dir not being available in the adapterdata container
    os.makedirs(join(dir, 'logs/'))

    return 0


def parse_args():
    """Parses the command line arguments to choose which action should be taken
    """
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(
        help='commands (use "layersbox -h command" to find out about their \
        parameters)',
        dest='command')

    start_parser = subparsers.add_parser('start', help='Starts the LayersBox')
    start_parser.add_argument('--directory', '-d', action='store',
                              help='Directory of the box', default='.')
    start_parser.set_defaults(func=box_start)

    stop_parser = subparsers.add_parser("stop", help="Stops the LayersBox")
    stop_parser.add_argument('--directory', '-d', action='store',
                             help='Directory of the box', default='.')
    stop_parser.set_defaults(func=box_stop)

    init_parser = subparsers.add_parser(
        "init",
        help="Initializes a LayersBox in the current directory")
    init_parser.add_argument(
        '--directory', '-d', action='store',
        help='The directory to use', default='.')

    init_parser.set_defaults(func=box_init)

    # logs_parser = subparsers.add_parser(
    #     'logs', help='Shows logs of the LayersBox')
    # logs_parser.add_argument('--directory', '-d', action='store',
    #                          help='Directory of the box', default='.')
    # logs_parser.set_defaults(func=box_logs)

    ps_parser = subparsers.add_parser(
        'status',
        help='Shows the states of the services inside the LayersBox')
    ps_parser.add_argument('--directory', '-d', action='store',
                           help='Directory of the box', default='.')
    ps_parser.set_defaults(func=box_ps)

    install_parser = subparsers.add_parser(
        'install', help='Adds a component to the LayersBox')
    install_parser.add_argument(
        'repository', action='store',
        help='Github repository of the service. Example: "owner/repo#version"')
    install_parser.add_argument('--directory', '-d', action='store',
                                help='Directory of the box', default='.')
   # install_parser.add_argument(
   #     '--version', '-v', action='store', nargs=1,
   #     help='The version to use; incompatible with the "-t" option.')

   # install_parser.add_argument(
   #     '--tag', '-t', action='store', nargs=1,
   #     help='The tag to use; incompatible with the "-v" option.', default='latest')

   # gr = parser.add_mutually_exclusive_group()
   # gr.add_argument("-v", "--version")
   # gr.add_argument("-t", "--tag")

    install_parser.set_defaults(func=box_install)

    return parser.parse_args()


def check_yml(dir):
    """Check if base.yml exists
    :returns: True if it exists, False otherwise
    """
    try:
        os.stat(join(dir, base))
        return True
    except:
        print("{} is missing in directory {}.".format(base, dir))
        sys.exit(1)
    return False


def main():
    """Entrypoint
    """
    if not check_programs(programs):
        sys.exit(1)

    parsed = parse_args()
    sys.exit(parsed.func(parsed))


if __name__ == "__main__":
    main()
